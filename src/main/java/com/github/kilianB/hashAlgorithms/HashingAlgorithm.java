package com.github.kilianB.hashAlgorithms;

import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;

import javax.imageio.ImageIO;

import com.github.kilianB.Require;
import com.github.kilianB.graphics.ImageUtil.FastPixel;
import com.github.kilianB.hashAlgorithms.filter.Kernel;
import com.github.kilianB.matcher.Hash;

/**
 * Base class for hashing algorithms returning perceptual hashes for supplied
 * images reducing the number of bits needed to represent said image.
 * 
 * <p>
 * Opposed to cryptographic hashes, hashes computed by these classes are
 * entirely predictable. Similarity metrics applied to these hashes shall
 * produce a higher score for closely related images.
 * 
 * <p>
 * If implementing impose a limitation on the lower bounds on the dimension of
 * hashable images the method {@link #getKeyResolution()} has to be overridden.
 * 
 * <p>
 * Unless otherwise noted hashing algorithms are thread safe.
 * 
 * @author Kilian
 * @since 1.0.0
 */
public abstract class HashingAlgorithm implements Serializable {

	// TODO Kernels serializable

	public static void main(String[] args) throws IOException {

		// Lets try some kernels

		List<Kernel> preProcessing = new ArrayList<Kernel>();

		preProcessing.add(Kernel.gaussianFilter(5, 5, 3));

		BufferedImage image = ImageIO.read(new File("src/test/resources/TestShapes.png"));

		BufferedImage bi = new BufferedImage(image.getWidth(), image.getHeight(), image.getType());
		FastPixel fp = new FastPixel(image);
		FastPixel fpSet = new FastPixel(bi);
		int[][] red = fp.getRed();
		int[][] green = fp.getGreen();
		int[][] blue = fp.getBlue();

		// Edge detection calculate

		// Grayscale average

		for (int x = 0; x < red.length; x++) {
			for (int y = 0; y < red[0].length; y++) {
				int gray = (red[x][y] + green[x][y] + blue[x][y]) / 3;
				red[x][y] = gray;
				green[x][y] = gray;
				blue[x][y] = gray;
			}
		}

//		for(Kernel kernel: preProcessing) {
//			red = kernel.applyInt(red);
//			green = kernel.applyInt(green);
//			blue = kernel.applyInt(blue);
//		}

		for (Kernel kernel : preProcessing) {
			red = kernel.applyInt(red);
			green = red;
			blue = red;
		}

		fpSet.setRed(red);
		fpSet.setGreen(green);
		fpSet.setBlue(blue);

		try {
			ImageIO.write(bi, "png", new File("Gray1.png"));
		} catch (Exception e) {
			// TODO: handle exception
		}

	}

	// maybe move to bitsets//Mutable inetegers? not efficient for small keys?
	protected List<Kernel> preProcessing = new ArrayList<>();

	private static final long serialVersionUID = 3L;

	/**
	 * The target bit resolution supplied during algorithm creation. This number
	 * represents the number of bits the final hash SHOULD have, but does not
	 * necessarily reflect it's actual length.
	 * <p>
	 * Therefore, it is not advised to use this value during computation of the hash
	 * unless you made sure that the value actually reflects
	 * 
	 */
	protected final int bitResolution;

	/** The actual bit resolution of produced hashes */
	protected int keyResolution = -1;

	/**
	 * The algorithm id of this hashing algorithm. The algorithm id specifies a
	 * unique identifier which allows to check if two distinct hashes are created by
	 * the same hashing algorithm and therefore are comparable. Even algorithms with
	 * the same
	 */
	protected int algorithmId;

	// TODO transient?
	private boolean hashComputed = false;

	private static final String LOCKED_MODIFICATION_EXCEPTION = "Hashing algorithms may only be "
			+ "modified as long as no hash has been generated by this object. This limitation is "
			+ "imposed to ensure that each hash is associated with the correct algorithm id which "
			+ "might change if the internal state of the algorithm is altered. Be aware"
			+ " that method like getKeyResolution() already perform a hashing operation "
			+ "and therefore invalidate further modification requests";

	/**
	 * Promises a key with approximately bit resolution (+ 1 padding bit). Due to
	 * geometric requirements the key might be marginally larger or smaller than
	 * specified. Hashing algorithms shall try to at least provide the number of
	 * bits specified
	 * 
	 * @param bitResolution The bit count of the final hash
	 */
	public HashingAlgorithm(int bitResolution) {

		bitResolution = Require.positiveValue(bitResolution,
				"The bit resolution for hashing algorithms has to be positive");
		this.bitResolution = bitResolution;
	}

	/**
	 * Calculate a hash for the given image. Invoking the hash function on the same
	 * image has to return the same hash value. A comparison of the hashes relates
	 * to the similarity of the images. The lower the value the more similar the
	 * images are. Equal images will produce a similarity of 0.
	 * 
	 * @param image Image whose hash will be calculated
	 * @return The hash representing the image
	 * @see Hash
	 */
	public Hash hash(BufferedImage image) {

		// TODO update hash

		// If we have kernels defined alter red green and blue values accordingly
		if (!preProcessing.isEmpty()) {
			BufferedImage bi = new BufferedImage(image.getWidth(), image.getHeight(), image.getType());
			FastPixel fp = new FastPixel(image);
			FastPixel fpSet = new FastPixel(bi);
			int[][] red = fp.getRed();
			int[][] green = fp.getGreen();
			int[][] blue = fp.getBlue();

			for (Kernel kernel : preProcessing) {
				red = kernel.applyInt(red);
				green = kernel.applyInt(green);
				blue = kernel.applyInt(blue);
			}

			fpSet.setRed(red);
			fpSet.setGreen(green);
			fpSet.setBlue(blue);

			image = bi;
		}
		hashComputed = true;
		return new Hash(hash(image, BigInteger.ZERO), getKeyResolution(), algorithmId());
	}

	/**
	 * Calculate a hash for the given image. Invoking the hash function on the same
	 * image has to return the same hash value. A comparison of the hashes relates
	 * to the similarity of the images. The lower the value the more similar the
	 * images are. Equal images will produce a similarity of 0.
	 * 
	 * @param imageFile The file pointing to the image
	 * @return The hash representing the image
	 * @throws IOException if an error occurs during loading the image
	 * @see Hash
	 */
	public Hash hash(File imageFile) throws IOException {
		hashComputed = true;
		return hash(ImageIO.read(imageFile));
	}

	/**
	 * Calculate a hash for the given image. Invoking the hash function on the same
	 * image has to return the same hash value. A comparison of the hashes relates
	 * to the similarity of the images. The lower the value the more similar the
	 * images are. Equal images will produce a similarity of 0.
	 * 
	 * <p>
	 * This method is intended to be overwritten by implementations and takes a
	 * baseHash argument to allow concatenating multiple hashes as well to be able
	 * to compute the effective hash length in {@link #getKeyResolution()}.
	 * Preceding 0's are omitted in big integer objects, while the usual hamming
	 * distance can be calculated due to xoring without issue the normalized
	 * distance requires the potential length of the key to be known.
	 * 
	 * @param image Image whose hash will be calculated
	 * @param hash  the big integer used to store the hash value
	 * @return the hash encoded as a big integer
	 */
	protected abstract BigInteger hash(BufferedImage image, BigInteger hash);

	/**
	 * A unique id identifying the settings and algorithms used to generate the
	 * output result. The id shall stay consistent throughout restarts of the jvm.
	 * 
	 * <p>
	 * Even if different bitResolutions are used in the constructor
	 * {@link #HashingAlgorithm(int)} the algorithId <b>MUST</b> return the same id
	 * for two instances if the returned hashes for the same input will always be
	 * equal. Therefore instead of checking against the bitResolution the actual
	 * resolution as returned by {@link #getKeyResolution()} should be used.
	 * 
	 * @return the algorithm id identifying this hashing algorithm
	 */
	public abstract int algorithmId();

	protected abstract int precomputeAlgoId();

	/**
	 * Get the actual bit key resolution of all hashes computed by this algorithm.
	 * 
	 * <p>
	 * Be aware that this value may differ from:
	 * 
	 * <ul>
	 * <li>the supplied bit resolution during algorithm creation due to geometric
	 * constraints of the hashing algorithm.</li>
	 * <li>the returned hash's {@link java.math.BigInteger#bitCount()} value due to
	 * preceding 0 bits being truncated in the big integer</li>
	 * </ul>
	 * 
	 * @return the actual bit resolution of the hash.
	 */
	public int getKeyResolution() {
		// If they key resolution is not know compute a sample hash and cache it's
		// return value
		if (keyResolution < 0) {
			BufferedImage bi = new BufferedImage(1, 1, BufferedImage.TYPE_3BYTE_BGR);
			// By preceding a ONE bit we don't fall victim to the 0 bit truncation.
			keyResolution = this.hash(bi, BigInteger.ONE).bitLength() - 1;
		}
		return keyResolution;
	}

	/**
	 * Add a {@link com.github.kilianB.hashAlgorithms.filter.Kernel Kernel} to this
	 * hashing algorithm which will be used to alter the image before the hashing
	 * operation is applied. Kernels are invoked in the order they are added and are
	 * performed individually on all 3 RGB channels.
	 * 
	 * <p>
	 * Be aware that kernels can only be added or removed until the first hash is
	 * computed. This limitation is enforced due to modified Kernels changing the
	 * hashcode of the object which might be used in hash collections leading to the
	 * object not being found after said operation.
	 * 
	 * @param kernel The kernel to add.
	 * @throws NullPointerException  if kernel is null
	 * @throws IllegalStateException if a hash was already created and the object is
	 *                               considered immutable.
	 * @since 2.0.0
	 */
	public void addKernel(Kernel kernel) {
		Objects.requireNonNull(kernel);

		if (hashComputed) {
			throw new IllegalStateException(LOCKED_MODIFICATION_EXCEPTION);
		}

		this.preProcessing.add(kernel);
	}

	/**
	 * Remove the first occurance of a
	 * {@link com.github.kilianB.hashAlgorithms.filter.Kernel Kernel} from this
	 * hashing algorithm.
	 * 
	 * <p>
	 * Be aware that kernels can only be added or removed until the first hash is
	 * computed. This limitation is enforced due to modified Kernels changing the
	 * hashcode of the object which might be used in hash collections leading to the
	 * object not being found after said operation.
	 * 
	 * @param kernel The kernel to add.
	 * @return true if the kernel was removed. False otherwise
	 * @throws IllegalStateException if a hash was already created and the object is
	 *                               considered immutable.
	 * @since 2.0.0
	 */
	public boolean removeKernel(Kernel kernel) {

		if (hashComputed) {
			throw new IllegalStateException(LOCKED_MODIFICATION_EXCEPTION);
		}

		return this.preProcessing.remove(kernel);
	}

	@Override
	public String toString() {
		return getClass().getSimpleName() + " [" + bitResolution + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + algorithmId();
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		HashingAlgorithm other = (HashingAlgorithm) obj;
		if (algorithmId() != other.algorithmId())
			return false;
		return true;
	}
}
